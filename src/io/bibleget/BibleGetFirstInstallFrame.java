/*
 * Copyright 2020 johnrdorazio.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.bibleget;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import javax.net.ssl.HttpsURLConnection;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JProgressBar;
import javax.swing.SwingWorker;
import javax.swing.text.DefaultCaret;
import org.apache.commons.lang3.SystemUtils;

/**
 *
 * @author johnrdorazio
 */
public class BibleGetFirstInstallFrame extends javax.swing.JFrame {

    private final ImageIcon loadingIco = new ImageIcon(getClass().getResource("/io/bibleget/images/loading.gif"));
    private final ImageIcon checkmarkIco = new ImageIcon(getClass().getResource("/io/bibleget/images/green-checkmark.png"));
    private final ImageIcon xmarkIco = new ImageIcon(getClass().getResource("/io/bibleget/images/red-x-wrong-mark.png"));
    private final ArrayList<JProgressBar> jProgressBars = new ArrayList<>();
    private char[] passwd; //if user chooses to type their password to install dependencies, it will be forgotten immediately after for security
    private ProcessBuilder builder = new ProcessBuilder();
    private Process process;
    BibleGetIO.StreamGobbler streamGobbler;
    
    /**
     * Creates new form BibleGetFirstInstallFrame
     */
    public BibleGetFirstInstallFrame() {
        
        initComponents();
        
        jProgressBars.add(jProgressBarDownloading);
        jProgressBars.add(jProgressBarCopying);
        jProgressBars.add(jProgressBarInstalling);
        jProgressBars.add(jProgressBarPreparing);
        jProgressBars.add(jProgressBarTotal);
        Task_Force tf = null;
        switch(BibleGetIO.ADDONSTATE){
            case JCEFUNINITIALIZED:
                tf = new Task_Force(jProgressBars,"DOWNLOADJCEF");
                break;
            case JCEFDOWNLOADED:
                jLabelDownloading.setIcon(checkmarkIco);
                tf = new Task_Force(jProgressBars,"COPYJCEF");
                break;
            case JCEFCOPIED:
                jLabelDownloading.setIcon(checkmarkIco);
                jLabelCopying.setIcon(checkmarkIco);
                tf = new Task_Force(jProgressBars,"INSTALLDEPENDENCIES");
                break;
            case JCEFDEPENDENCIES:
                jLabelDownloading.setIcon(checkmarkIco);
                jLabelCopying.setIcon(checkmarkIco);
                jLabelInstalling.setIcon(checkmarkIco);
                tf = new Task_Force(jProgressBars,"PREPAREENV");
                break;
            case JCEFENVREADY:
                jLabelDownloading.setIcon(checkmarkIco);
                jLabelCopying.setIcon(checkmarkIco);
                jLabelInstalling.setIcon(checkmarkIco);
                jLabelPreparing.setIcon(checkmarkIco);
                break;
        }
        if(null != tf){
            tf.execute();
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanelIntro = new javax.swing.JPanel();
        jTextArea1 = new javax.swing.JTextArea();
        jPanelDownloading = new javax.swing.JPanel();
        jLabelDownloading = new javax.swing.JLabel();
        jLabelDownloading.setHorizontalTextPosition(JLabel.LEFT);
        jProgressBarDownloading = new javax.swing.JProgressBar();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextAreaDownloading = new javax.swing.JTextArea();
        DefaultCaret caret = (DefaultCaret)jTextAreaDownloading.getCaret();
        caret.setUpdatePolicy(DefaultCaret.ALWAYS_UPDATE);
        jPanelCopying = new javax.swing.JPanel();
        jLabelCopying = new javax.swing.JLabel();
        jLabelCopying.setHorizontalTextPosition(JLabel.LEFT);
        jProgressBarCopying = new javax.swing.JProgressBar();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextAreaCopying = new javax.swing.JTextArea();
        DefaultCaret caret1 = (DefaultCaret)jTextAreaCopying.getCaret();
        caret1.setUpdatePolicy(DefaultCaret.ALWAYS_UPDATE);
        jPanelInstalling = new javax.swing.JPanel();
        jLabelInstalling = new javax.swing.JLabel();
        jLabelInstalling.setHorizontalTextPosition(JLabel.LEFT);
        jProgressBarInstalling = new javax.swing.JProgressBar();
        jPanel1 = new javax.swing.JPanel();
        jLabel6 = new javax.swing.JLabel();
        jPasswordField1 = new javax.swing.JPasswordField();
        jButton1 = new javax.swing.JButton();
        jLabel7 = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextAreaInstalling = new javax.swing.JTextArea();
        jPanelPreparing = new javax.swing.JPanel();
        jLabelPreparing = new javax.swing.JLabel();
        jLabelPreparing.setHorizontalTextPosition(JLabel.LEFT);
        jProgressBarPreparing = new javax.swing.JProgressBar();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTextAreaPreparing = new javax.swing.JTextArea();
        jPanelBottom = new javax.swing.JPanel();
        jLabelTotalProgress = new javax.swing.JLabel();
        jProgressBarTotal = new javax.swing.JProgressBar();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("BibleGet installation");
        setAlwaysOnTop(true);
        setMaximumSize(new java.awt.Dimension(700, 700));
        setMinimumSize(new java.awt.Dimension(700, 700));
        setPreferredSize(new java.awt.Dimension(700, 700));
        getContentPane().setLayout(new javax.swing.BoxLayout(getContentPane(), javax.swing.BoxLayout.PAGE_AXIS));

        jPanelIntro.setPreferredSize(new java.awt.Dimension(675, 50));

        jTextArea1.setEditable(false);
        jTextArea1.setColumns(20);
        jTextArea1.setLineWrap(true);
        jTextArea1.setRows(2);
        jTextArea1.setText("In order to function correctly, the BibleGet add-on for OpenOffice requires some additional components.\nPlease wait patiently while the setup process completes.");
        jTextArea1.setWrapStyleWord(true);
        jTextArea1.setOpaque(false);
        jTextArea1.setPreferredSize(new java.awt.Dimension(675, 30));

        javax.swing.GroupLayout jPanelIntroLayout = new javax.swing.GroupLayout(jPanelIntro);
        jPanelIntro.setLayout(jPanelIntroLayout);
        jPanelIntroLayout.setHorizontalGroup(
            jPanelIntroLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelIntroLayout.createSequentialGroup()
                .addComponent(jTextArea1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 1329, Short.MAX_VALUE))
        );
        jPanelIntroLayout.setVerticalGroup(
            jPanelIntroLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTextArea1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        getContentPane().add(jPanelIntro);

        jPanelDownloading.setPreferredSize(new java.awt.Dimension(675, 140));

        jLabelDownloading.setFont(new java.awt.Font("Dialog", 1, 14)); // NOI18N
        jLabelDownloading.setIcon(loadingIco);
        jLabelDownloading.setText("1. Downloading JCEF component...");
        jLabelDownloading.setMaximumSize(new java.awt.Dimension(450, 22));
        jLabelDownloading.setPreferredSize(new java.awt.Dimension(450, 24));

        jProgressBarDownloading.setMaximumSize(new java.awt.Dimension(675, 20));
        jProgressBarDownloading.setPreferredSize(new java.awt.Dimension(675, 20));
        jProgressBarDownloading.setStringPainted(true);

        jTextAreaDownloading.setEditable(false);
        jTextAreaDownloading.setColumns(20);
        jTextAreaDownloading.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        jTextAreaDownloading.setForeground(new java.awt.Color(0, 102, 0));
        jTextAreaDownloading.setRows(5);
        jTextAreaDownloading.setText("Establishing connection to the github repo for the JCEF component https://github.com/jcefbuild/jcefbuild...\n");
        jTextAreaDownloading.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jScrollPane1.setViewportView(jTextAreaDownloading);

        javax.swing.GroupLayout jPanelDownloadingLayout = new javax.swing.GroupLayout(jPanelDownloading);
        jPanelDownloading.setLayout(jPanelDownloadingLayout);
        jPanelDownloadingLayout.setHorizontalGroup(
            jPanelDownloadingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelDownloadingLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelDownloadingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane1)
                    .addComponent(jLabelDownloading, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jProgressBarDownloading, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(1317, Short.MAX_VALUE))
        );
        jPanelDownloadingLayout.setVerticalGroup(
            jPanelDownloadingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelDownloadingLayout.createSequentialGroup()
                .addComponent(jLabelDownloading, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jProgressBarDownloading, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        getContentPane().add(jPanelDownloading);

        jPanelCopying.setPreferredSize(new java.awt.Dimension(675, 140));

        jLabelCopying.setFont(new java.awt.Font("Dialog", 1, 14)); // NOI18N
        jLabelCopying.setIcon(loadingIco);
        jLabelCopying.setText("2. Copying JCEF component files...");
        jLabelCopying.setMaximumSize(new java.awt.Dimension(450, 22));
        jLabelCopying.setPreferredSize(new java.awt.Dimension(450, 22));

        jProgressBarCopying.setPreferredSize(new java.awt.Dimension(675, 20));
        jProgressBarCopying.setStringPainted(true);

        jTextAreaCopying.setEditable(false);
        jTextAreaCopying.setColumns(20);
        jTextAreaCopying.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        jTextAreaCopying.setForeground(new java.awt.Color(0, 102, 0));
        jTextAreaCopying.setRows(5);
        jScrollPane2.setViewportView(jTextAreaCopying);

        javax.swing.GroupLayout jPanelCopyingLayout = new javax.swing.GroupLayout(jPanelCopying);
        jPanelCopying.setLayout(jPanelCopyingLayout);
        jPanelCopyingLayout.setHorizontalGroup(
            jPanelCopyingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCopyingLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelCopyingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jProgressBarCopying, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane2)
                    .addComponent(jLabelCopying, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(1317, Short.MAX_VALUE))
        );
        jPanelCopyingLayout.setVerticalGroup(
            jPanelCopyingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCopyingLayout.createSequentialGroup()
                .addComponent(jLabelCopying, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jProgressBarCopying, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 71, Short.MAX_VALUE))
        );

        getContentPane().add(jPanelCopying);

        jPanelInstalling.setPreferredSize(new java.awt.Dimension(675, 190));

        jLabelInstalling.setFont(new java.awt.Font("Dialog", 1, 14)); // NOI18N
        jLabelInstalling.setIcon(loadingIco);
        jLabelInstalling.setText("3. Installing system dependencies...");
        jLabelInstalling.setMaximumSize(new java.awt.Dimension(450, 22));
        jLabelInstalling.setMinimumSize(new java.awt.Dimension(450, 22));
        jLabelInstalling.setPreferredSize(new java.awt.Dimension(450, 24));

        jProgressBarInstalling.setMaximumSize(new java.awt.Dimension(675, 20));
        jProgressBarInstalling.setPreferredSize(new java.awt.Dimension(675, 20));
        jProgressBarInstalling.setStringPainted(true);

        jPanel1.setLayout(new java.awt.FlowLayout(0));

        jLabel6.setText("System password:");
        jPanel1.add(jLabel6);

        jPasswordField1.setText("jPasswordField1");
        jPanel1.add(jPasswordField1);

        jButton1.setText("OK");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });
        jPanel1.add(jButton1);

        jLabel7.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        jLabel7.setForeground(new java.awt.Color(153, 0, 0));
        jLabel7.setMaximumSize(new java.awt.Dimension(20, 20));
        jLabel7.setMinimumSize(new java.awt.Dimension(20, 20));
        jLabel7.setPreferredSize(new java.awt.Dimension(350, 20));
        jPanel1.add(jLabel7);

        jTextAreaInstalling.setEditable(false);
        jTextAreaInstalling.setColumns(20);
        jTextAreaInstalling.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        jTextAreaInstalling.setForeground(new java.awt.Color(0, 102, 0));
        jTextAreaInstalling.setRows(5);
        jTextAreaInstalling.setPreferredSize(new java.awt.Dimension(675, 65));
        jScrollPane3.setViewportView(jTextAreaInstalling);

        javax.swing.GroupLayout jPanelInstallingLayout = new javax.swing.GroupLayout(jPanelInstalling);
        jPanelInstalling.setLayout(jPanelInstallingLayout);
        jPanelInstallingLayout.setHorizontalGroup(
            jPanelInstallingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelInstallingLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelInstallingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jProgressBarInstalling, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabelInstalling, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane3))
                .addGap(1317, 1317, 1317))
        );
        jPanelInstallingLayout.setVerticalGroup(
            jPanelInstallingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelInstallingLayout.createSequentialGroup()
                .addComponent(jLabelInstalling, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jProgressBarInstalling, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        getContentPane().add(jPanelInstalling);

        jPanelPreparing.setPreferredSize(new java.awt.Dimension(675, 150));

        jLabelPreparing.setFont(new java.awt.Font("Dialog", 1, 14)); // NOI18N
        jLabelPreparing.setIcon(loadingIco);
        jLabelPreparing.setText("4. Preparing environment...");
        jLabelPreparing.setMaximumSize(new java.awt.Dimension(450, 22));
        jLabelPreparing.setMinimumSize(new java.awt.Dimension(450, 22));
        jLabelPreparing.setPreferredSize(new java.awt.Dimension(450, 24));

        jProgressBarPreparing.setPreferredSize(new java.awt.Dimension(675, 20));
        jProgressBarPreparing.setStringPainted(true);

        jTextAreaPreparing.setEditable(false);
        jTextAreaPreparing.setColumns(20);
        jTextAreaPreparing.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        jTextAreaPreparing.setForeground(new java.awt.Color(0, 102, 0));
        jTextAreaPreparing.setRows(5);
        jTextAreaPreparing.setPreferredSize(new java.awt.Dimension(675, 65));
        jScrollPane4.setViewportView(jTextAreaPreparing);

        javax.swing.GroupLayout jPanelPreparingLayout = new javax.swing.GroupLayout(jPanelPreparing);
        jPanelPreparing.setLayout(jPanelPreparingLayout);
        jPanelPreparingLayout.setHorizontalGroup(
            jPanelPreparingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelPreparingLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelPreparingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabelPreparing, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(jPanelPreparingLayout.createSequentialGroup()
                        .addGroup(jPanelPreparingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jProgressBarPreparing, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jScrollPane4))
                        .addGap(0, 1305, Short.MAX_VALUE)))
                .addContainerGap())
        );
        jPanelPreparingLayout.setVerticalGroup(
            jPanelPreparingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelPreparingLayout.createSequentialGroup()
                .addComponent(jLabelPreparing, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jProgressBarPreparing, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        getContentPane().add(jPanelPreparing);

        jPanelBottom.setPreferredSize(new java.awt.Dimension(675, 50));

        jLabelTotalProgress.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabelTotalProgress.setText("Total progress");
        jLabelTotalProgress.setPreferredSize(new java.awt.Dimension(148, 15));

        jProgressBarTotal.setStringPainted(true);

        javax.swing.GroupLayout jPanelBottomLayout = new javax.swing.GroupLayout(jPanelBottom);
        jPanelBottom.setLayout(jPanelBottomLayout);
        jPanelBottomLayout.setHorizontalGroup(
            jPanelBottomLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelBottomLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelBottomLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabelTotalProgress, javax.swing.GroupLayout.DEFAULT_SIZE, 671, Short.MAX_VALUE)
                    .addComponent(jProgressBarTotal, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(1321, Short.MAX_VALUE))
        );
        jPanelBottomLayout.setVerticalGroup(
            jPanelBottomLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelBottomLayout.createSequentialGroup()
                .addComponent(jLabelTotalProgress, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jProgressBarTotal, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        getContentPane().add(jPanelBottom);

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        passwd = jPasswordField1.getPassword();
        jPasswordField1.setText("***************");
        if( passwd != null && passwd.length > 0 ){
            jLabel7.setText("");
            Task_Force tf = new Task_Force(jProgressBars,"INSTALLDEPENDENCIES");
            tf.execute();
        } else {
            jLabel7.setText("Password is empty, cannot continue. Please type password, or run shell script.");
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(BibleGetFirstInstallFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(BibleGetFirstInstallFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(BibleGetFirstInstallFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(BibleGetFirstInstallFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new BibleGetFirstInstallFrame().setVisible(true);
        });
    }
    
    private class Task_Force extends SwingWorker<Void, Integer> {
        JProgressBar jProgressBarDownloading;
        JProgressBar jProgressBarCopying;
        JProgressBar jProgressBarInstalling;
        JProgressBar jProgressBarPreparing;
        JProgressBar jProgressBarTotal;
        ArrayList<JProgressBar> jProgressBars;
        String currentTask;
        
        public Task_Force(ArrayList<JProgressBar> jpbs,String task){
            this.jProgressBarDownloading = jpbs.get(0);
            this.jProgressBarCopying = jpbs.get(1);
            this.jProgressBarInstalling = jpbs.get(2);
            this.jProgressBarPreparing = jpbs.get(3);
            this.jProgressBarTotal = jpbs.get(4);
            this.jProgressBars = jpbs;
            this.currentTask = task;
        }

        @Override
        protected void process(List<Integer> chunks) {
            int i = chunks.get(chunks.size()-1);
            Double totalProgress;
            switch(this.currentTask){
                case "DOWNLOADJCEF":
                    this.jProgressBarDownloading.setValue(i); // The last value in this array is all we care about.
                    totalProgress = Double.valueOf(i) / Double.valueOf(4);
                    this.jProgressBarTotal.setValue((int) Math.round(totalProgress));
                    break;
                case "COPYJCEF":
                    this.jProgressBarDownloading.setValue(100);
                    this.jProgressBarCopying.setValue(i);
                    totalProgress = Double.valueOf(i) / Double.valueOf(4);
                    this.jProgressBarTotal.setValue(25 + (int) Math.round(totalProgress));
                    break;
                case "INSTALLDEPENDENCIES":
                    this.jProgressBarDownloading.setValue(100);
                    this.jProgressBarCopying.setValue(100);
                    this.jProgressBarInstalling.setValue(i);
                    totalProgress = Double.valueOf(i) / Double.valueOf(4);
                    this.jProgressBarTotal.setValue(50 + (int) Math.round(totalProgress));
                    break;
                case "PREPAREENV":
                    this.jProgressBarDownloading.setValue(100);
                    this.jProgressBarCopying.setValue(100);
                    this.jProgressBarInstalling.setValue(100);
                    this.jProgressBarPreparing.setValue(i);
                    totalProgress = Double.valueOf(i) / Double.valueOf(4);
                    this.jProgressBarTotal.setValue(75 + (int) Math.round(totalProgress));
                    break;
            }
            //System.out.println(i);            
        }
        
        @Override
        protected Void doInBackground() throws Exception {
            publish(0);
            System.out.println("BibleGetFirstInstall started background worker for task " + this.currentTask);
            switch(this.currentTask){
                case "DOWNLOADJCEF":
                    try {
                        System.out.println("starting downloadJCEF process...");
                        //following URLs retrieved via the github api at
                        //    https://api.github.com/repos/jcefbuild/jcefbuild/releases/30632029/assets
                        // actually the same information is present in:
                        //    https://api.github.com/repos/jcefbuild/jcefbuild/releases
                        // use Accept header = application/vnd.github.v3+json in order to retrieve results in JSON notation
                        // the result of this last API endpoint is an ARRAY of objects, the first of which should be the latest release
                        // but in order to target a specific release, search for "tag_name" (or "name", should be the same) 
                        //     as indicated in the following JCEFbuild String
                        //     The object that has this "tag_name" will also have an "assets" property at the same level as "tag_name"
                        //     "assets" is again an ARRAY of OBJECTS
                        //     We must search for objects that have "name" of: {"linux32.zip", "linux64.zip", "macosx64.zip", "win32.zip"}
                        //     and get their "url" and perhaps "content_type"

                        String JCEFbuild = "v1.0.10-84.3.8+gc8a556f+chromium-84.0.4147.105";
                        String[] targetOS = new String[]{"linux32.zip", "linux64.zip", "macosx64.zip", "win32.zip"};

                        //Until we automate the process, here are the hardcoded URLs for the target OSs, for the indicated release:
                        String linux32URL = "https://api.github.com/repos/jcefbuild/jcefbuild/releases/assets/24791124";
                        String linux64URL = "https://api.github.com/repos/jcefbuild/jcefbuild/releases/assets/24791106";
                        String macosx64URL = "https://api.github.com/repos/jcefbuild/jcefbuild/releases/assets/24791232";
                        String win32URL = "https://api.github.com/repos/jcefbuild/jcefbuild/releases/assets/24791067";

                        URL downloadURL = null;
                        if(SystemUtils.IS_OS_WINDOWS){
                            downloadURL = new URL(win32URL);
                        } else if (SystemUtils.IS_OS_MAC_OSX){
                            downloadURL = new URL(macosx64URL);
                        } else if (SystemUtils.IS_OS_LINUX){
                            switch(System.getProperty("sun.arch.data.model")){
                                case "64":
                                    downloadURL = new URL(linux64URL);
                                    break;
                                case "32":
                                    downloadURL = new URL(linux32URL);
                                    break;
                            }
                        }
                        //System.out.println("download URL was detected as " + downloadURL.toString());

                        HttpsURLConnection con;
                        con = (HttpsURLConnection) downloadURL.openConnection();
                        con.setConnectTimeout(1000);
                         // optional default is GET
                        con.setRequestMethod("GET");
                        con.setRequestProperty("Accept", "application/octet-stream");

                        //System.out.println("Sending 'GET' request to URL : " + url);
                        //System.out.println("Response Code : " + con.getResponseCode());
                        int respCode;
                        respCode = con.getResponseCode();
                        Path outDir = null;
                        if(HttpsURLConnection.HTTP_OK == respCode) {
                            if(SystemUtils.IS_OS_LINUX || SystemUtils.IS_OS_WINDOWS ){
                                outDir = Paths.get(System.getProperty("java.io.tmpdir"),"BibleGetJCEF");
                                System.out.println("Temp directory where JCEF should or will be stored was detected as " + outDir.toString());
                                if(Files.notExists(outDir)){
                                    System.out.println("The BibleGetJCEF directory in the temp folder was not found, now creating...");
                                    File jcefDirectoryTMP = new File(outDir.toString());
                                    jcefDirectoryTMP.mkdir();
                                }
                            } else if( SystemUtils.IS_OS_MAC_OSX ){
                                outDir = Paths.get(System.getProperty("user.home"), "Library", "BibleGetOpenOfficePlugin" );
                            }

                            byte[] buffer = new byte[2048];
                            try ( 
                                    InputStream conInStr = con.getInputStream();
                                    BufferedInputStream buffInStr = new BufferedInputStream(conInStr);
                                    ZipInputStream zipInStream = new ZipInputStream(buffInStr);
                                ) {
                                System.out.println("We seem to have a stream of data from the github assets...");
                                //int contentLength = con.getContentLength();
                                //System.out.println("our connection is predicting content length " + contentLength);
                                //the above prediction (86442538) is exact, when comparing with the value declared by github
                                //however we are reading the bytes after they are decompressed, which changes this value
                                //and we can't predict with certainty the total size of the decompressed zip
                                //but after testing we know the length = 215399768
                                int readLength = 0;
                                int percentageCompleted = 0;
                                int totalEntries = 0;
                                Double totalBytes = Double.valueOf(215399768);
                                Double onehundred = Double.valueOf(100);
                                ZipEntry entry;
                                while ((entry = zipInStream.getNextEntry()) != null && outDir != null) {
                                    totalEntries++;
                                    if(entry.isDirectory()){
                                        File entryFile = new File(outDir.toString(), entry.getName());
                                        if(entryFile.exists() == false){
                                            System.out.println("directory " + entryFile.getCanonicalPath() + " did not exist, now creating...");
                                            entryFile.mkdirs();
                                        }
                                        jTextAreaDownloading.append("Creating folder " + entry.getName() + "  (" + totalEntries + " of 137)\n");
                                    } else {
                                        Path filePath = outDir.resolve(entry.getName());
                                        //instead of checking whether the file exists, we'll simply overwrite by passing false as second parameter to FileOutputStream
                                        //let's keep life simple, it doesn't take that long
                                        //File entryFile = new File(outDir.toString(), entry.getName());
                                        //if(entryFile.exists() == false){
                                            try (FileOutputStream fos = new FileOutputStream(filePath.toFile(), false);
                                                    BufferedOutputStream bos = new BufferedOutputStream(fos, buffer.length)) {
                                                int len;
                                                while ((len = zipInStream.read(buffer)) > 0) {
                                                    bos.write(buffer, 0, len);
                                                    readLength += len;
                                                    Double progress = (Double.valueOf(readLength) / totalBytes);
                                                    percentageCompleted = (int) Math.round(progress * onehundred);
                                                    publish(percentageCompleted);
                                                    //System.out.println("readLength so far is " + len + " and percentage is " + percentageCompleted);
                                                }
                                            }
                                        //}
                                        jTextAreaDownloading.append("Unzipping " + entry.getName() + "  (" + totalEntries + " of 137)\n");
                                    }
                                    
                                    //Double progress = (Double.valueOf(totalEntries) / Double.valueOf(137));
                                    //percentageCompleted = (int) Math.round(progress * Double.valueOf(100));
                                    //publish(percentageCompleted);
                                    //System.out.println("entries so far is " + totalEntries + " and percentage is " + percentageCompleted);
                                }
                                System.out.println("total entries = " + totalEntries);
                                jTextAreaDownloading.append("Download of JCEF component and unzipping complete!");
                            }
                        }
                        con.disconnect();
                        BibleGetIO.ADDONSTATE = BGET.ADDONSTATE.JCEFDOWNLOADED;
                        System.out.println("ADDONSTATE changed to JCEFDOWNLOADED");
                        jLabelDownloading.setIcon(checkmarkIco);
                    } catch (IOException ex) {
                        jLabelDownloading.setIcon(xmarkIco);
                        Logger.getLogger(BibleGetFirstInstallFrame.class.getName()).log(Level.SEVERE, null, ex);
                        //Task_Force tf = new Task_Force(jProgressBars,"DOWNLOADJCEF");
                        //tf.execute();
                    }
                    break;
                case "COPYJCEF":
                    int totalFilesToCopy = 69;
                    int currentTotalCopied = 0;
                    Double progress;
                    
                    if(SystemUtils.IS_OS_LINUX || SystemUtils.IS_OS_WINDOWS){

                        //first let's check if the JCEF directory exists in the user's home under our BibleGetOpenOfficePlugin directory
                        //and if not, we create it
                        Path JCEFpath = Paths.get(BibleGetIO.nativelibrarypath);
                        if(Files.notExists(JCEFpath)){
                            File jcefDirectory = new File(BibleGetIO.nativelibrarypath);
                            jcefDirectory.mkdirs();
                            jTextAreaCopying.append("Creating directory " + JCEFpath.toString() + "...\n");
                        }

                        String tempDir = System.getProperty("java.io.tmpdir");
                        //check if the necessary files exist in the user.path BibleGetIOOpenOffice/JCEF folder
                        if(BibleGetIO.JCEFfiles != null){
                            for(String fileName : BibleGetIO.JCEFfiles ){
                                Path filePath = Paths.get(BibleGetIO.nativelibrarypath, fileName);
                                if(Files.notExists(filePath) ){
                                    Path tempFilePath = Paths.get(tempDir, "BibleGetJCEF", "java-cef-build-bin", "bin", "lib", BibleGetIO.ziplibrarypath, fileName);
                                    if(Files.notExists(tempFilePath)){
                                        //if the file doesn't even exist in the temp path then we need to download or re-download the package from github
                                        BibleGetIO.ADDONSTATE = BGET.ADDONSTATE.JCEFUNINITIALIZED;
                                    }
                                    //now we can copy the missing file from the tempDir
                                    //TODO: move this to BibleGetFirstInstallFrame.java
                                    if(BibleGetIO.ADDONSTATE == BGET.ADDONSTATE.JCEFDOWNLOADED){
                                        Files.copy(tempFilePath,filePath);
                                        currentTotalCopied++;
                                        jTextAreaCopying.append("Copying " + fileName + " (" + currentTotalCopied + " of " + totalFilesToCopy + ")\n");
                                        progress = (Double.valueOf(currentTotalCopied) / Double.valueOf(totalFilesToCopy)) * Double.valueOf(100);
                                        publish((int) Math.round(progress));
                                    }
                                } else {
                                    currentTotalCopied++;
                                    jTextAreaCopying.append("File already existed: " + fileName + " (" + currentTotalCopied + " of " + totalFilesToCopy + ")\n");
                                    progress = (Double.valueOf(currentTotalCopied) / Double.valueOf(totalFilesToCopy)) * Double.valueOf(100);
                                    publish((int) Math.round(progress));                                    
                                }
                            }
                        } else {
                            Logger.getLogger(BibleGetIO.class.getName()).log(Level.SEVERE, null, "setNativeLibraryDir() : We were not able to determine the correct folder structure for this system in order to ensure the correct functioning of the Chrome Embedded Framework.");
                        }

                        //check if the 'locales' subfolder exists in the user.path BibleGetIOOpenOffice/JCEF folder
                        //and if not create it
                        Path JCEFlocalespath = Paths.get(BibleGetIO.nativelibrarypath, "locales");
                        if(Files.notExists(JCEFlocalespath) ){
                            File jcefLocalesDir = new File(BibleGetIO.nativelibrarypath, "locales");
                            jcefLocalesDir.mkdir();
                            jTextAreaCopying.append("Creating directory " + JCEFlocalespath.toString() + "...\n");
                        }

                        //check if the necessary files exist in the 'locales' subfolder of the user.path BibleGetIOOpenOffice/JCEF folder
                        for(String fileName : BibleGetIO.JCEFlocaleFiles ){
                            Path filePath = Paths.get(BibleGetIO.nativelibrarypath, "locales", fileName);
                            if(Files.notExists(filePath) ){
                                Path tempFilePath = Paths.get(tempDir, "BibleGetJCEF", "java-cef-build-bin", "bin", "lib", BibleGetIO.ziplibrarypath, "locales", fileName);
                                if(Files.notExists(tempFilePath)){
                                    //if the file doesn't even exist in the temp path then we need to download or re-download the package from github
                                    BibleGetIO.ADDONSTATE = BGET.ADDONSTATE.JCEFUNINITIALIZED;
                                }
                                //now we can copy the missing file from the tempDir
                                //TODO: move this to BibleGetFirstInstallFrame.java
                                if(BibleGetIO.ADDONSTATE == BGET.ADDONSTATE.JCEFDOWNLOADED){
                                    Files.copy(tempFilePath,filePath);
                                    currentTotalCopied++;
                                    jTextAreaCopying.append("Copying " + fileName + " (" + currentTotalCopied + " of " + totalFilesToCopy + ")\n");
                                    progress = (Double.valueOf(currentTotalCopied) / Double.valueOf(totalFilesToCopy)) * Double.valueOf(100);
                                    publish((int) Math.round(progress));
                                }
                            } else {
                                currentTotalCopied++;
                                jTextAreaCopying.append("File already existed: " + fileName + " (" + currentTotalCopied + " of " + totalFilesToCopy + ")\n");
                                progress = (Double.valueOf(currentTotalCopied) / Double.valueOf(totalFilesToCopy)) * Double.valueOf(100);
                                publish((int) Math.round(progress));                                    
                            }
                        }

                        //check if the 'swiftshader' subfolder exists in the user.path BibleGetIOOpenOffice/JCEF folder
                        //and if not create it
                        Path JCEFswshaderpath = Paths.get(BibleGetIO.nativelibrarypath, "swiftshader");
                        if(Files.notExists(JCEFswshaderpath) ){
                            File jcefSwShaderDir = new File(BibleGetIO.nativelibrarypath, "swiftshader");
                            jcefSwShaderDir.mkdir();
                            jTextAreaCopying.append("Creating directory " + JCEFswshaderpath.toString() + "...\n");
                        }

                        //check if the necessary files exist in the 'swiftshader subfolder
                        if(BibleGetIO.JCEFswiftshaderFiles != null){
                            for(String fileName : BibleGetIO.JCEFswiftshaderFiles ){
                                Path filePath = Paths.get(BibleGetIO.nativelibrarypath, "swiftshader", fileName);
                                if(Files.notExists(filePath) ){
                                    Path tempFilePath = Paths.get(tempDir, "BibleGetJCEF", "java-cef-build-bin", "bin", "lib", BibleGetIO.ziplibrarypath, "swiftshader", fileName);
                                    if(Files.notExists(tempFilePath)){
                                        //if the file doesn't even exist in the temp path then we need to download or re-download the package from github
                                        BibleGetIO.ADDONSTATE = BGET.ADDONSTATE.JCEFUNINITIALIZED;
                                    }
                                    //now we can copy the missing file from the tempDir
                                    //TODO: move this to BibleGetFirstInstallFrame.java
                                    if(BibleGetIO.ADDONSTATE == BGET.ADDONSTATE.JCEFDOWNLOADED){
                                        Files.copy(tempFilePath,filePath);
                                        currentTotalCopied++;
                                        jTextAreaCopying.append("Copying " + fileName + " (" + currentTotalCopied + " of " + totalFilesToCopy + ")\n");
                                        progress = (Double.valueOf(currentTotalCopied) / Double.valueOf(totalFilesToCopy)) * Double.valueOf(100);
                                        publish((int) Math.round(progress));
                                    }
                                } else {
                                    currentTotalCopied++;
                                    jTextAreaCopying.append("File already existed: " + fileName + " (" + currentTotalCopied + " of " + totalFilesToCopy + ")\n");
                                    progress = (Double.valueOf(currentTotalCopied) / Double.valueOf(totalFilesToCopy)) * Double.valueOf(100);
                                    publish((int) Math.round(progress));                                    
                                }
                            }
                        } else {
                            Logger.getLogger(BibleGetIO.class.getName()).log(Level.SEVERE, null, "setNativeLibraryDir() : We were not able to determine the correct folder structure for this system in order to ensure the correct functioning of the Chrome Embedded Framework.");
                        }
                    } else if(SystemUtils.IS_OS_MAC_OSX){
                        //basically we don't nee the TEMP storage, because the app structure is exactly the same between the zip file and the user folder

                        //first let's check if the JCEF directory exists in the user's home under our BibleGetOpenOfficePlugin directory
                        //and if not, we create it
                        Path JCEFpath = Paths.get(BibleGetIO.nativelibrarypath);
                        if(Files.notExists(JCEFpath)){
                            //File jcefDirectory = new File(nativelibrarypath);
                            //jcefDirectory.mkdirs();
                            //The directory will be created when reading the zip file!
                            BibleGetIO.ADDONSTATE = BGET.ADDONSTATE.JCEFUNINITIALIZED;
                        }

                    }
                    
                    if (SystemUtils.IS_OS_LINUX) {
                        System.out.println("Now copying shell script from jar to disk...");
                        Path outFile = Paths.get(System.getProperty("user.home"),".BibleGetOpenOfficePlugin","firstinstall.sh");
                        //String systemUser = System.getProperty("user.name");
                        if(BibleGetIO.sofficeLaunch == null || BibleGetIO.sofficeLaunch.isEmpty() ){
                            Path launchFile = Paths.get(System.getProperty("user.home"),".BibleGetOpenOfficePlugin","launch.sh");
                            try {
                                ProcessBuilder builder = new ProcessBuilder();
                                builder.command("/bin/bash","-c","which soffice");
                                Process process = builder.start();
                                BibleGetIO.StreamGobbler streamGobbler = new BibleGetIO.StreamGobbler(process.getInputStream(), BibleGetIO::getLauncherPath);
                                Executors.newSingleThreadExecutor().submit(streamGobbler);
                                int exitCode = process.waitFor();
                                if(exitCode == 0){
                                    Thread.sleep(10);
                                    //we have the path to the soffice launcher, which is probably a symlink
                                    System.out.println("soffice launch file = " + BibleGetIO.sofficeLaunch);
                                    if(Files.exists(Paths.get(BibleGetIO.sofficeLaunch)) && Files.isSymbolicLink(Paths.get(BibleGetIO.sofficeLaunch)) ){
                                        //let's get the target path for the symbolic link
                                        Path realPath = Paths.get(BibleGetIO.sofficeLaunch).toRealPath();
                                        System.out.println("which is a symbolic link to : " + realPath.toString() + " (should equal: " + launchFile.toString() + ")");
                                        if(realPath.compareTo(launchFile) == 0){
                                            //SymLink is already pointing at launch.sh!
                                        } else {
                                            BibleGetIO.sofficeLaunchSymlink = realPath.toString();
                                            if(BibleGetIO.sofficeLaunchSymlink.contains("libreoffice")){
                                                //openoffice did not succeed in updating the symlink!
                                                //let us force update the symlink to point to openoffice
                                                if(Files.exists(Paths.get("/opt/openoffice4/program/soffice") ) ){
                                                    BibleGetIO.sofficeLaunchSymlink = "/opt/openoffice4/program/soffice";
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    System.out.println("BibleGetFirstInstallFrame: COPYJCEF: could not get detect soffice launch file");
                                }
                            } catch (IOException | InterruptedException ex) {
                                Logger.getLogger(BibleGetIO.class.getName()).log(Level.SEVERE, null, ex);
                            }
                        
                        }
                        System.out.println("value of BibleGetIO.sofficeLaunch = " + BibleGetIO.sofficeLaunch);
                        System.out.println("value of BibleGetIO.sofficeLaunchSymlink = " + BibleGetIO.sofficeLaunchSymlink);
                        try (FileWriter writer = new FileWriter(outFile.toFile()); BufferedWriter bf = new BufferedWriter(writer)) {
                            bf.write("#!/bin/bash");
                            bf.newLine();
                            bf.write("apt-get update && apt-get install " + String.join(" ", BibleGetIO.sysPkgsNeeded) );
                            bf.newLine();
                            bf.write("ln -sfn ~/.BibleGetOpenOfficePlugin/launch.sh " + BibleGetIO.sofficeLaunch );
                            bf.newLine();
                            //bf.write(String.format("echo \"export LD_LIBRARY_PATH=~/.BibleGetOpenOfficePlugin/JCEF\" | sudo -u %s tee -a ~/.bashrc",systemUser) );
                            //bf.newLine();
                            //bf.write(String.format("echo \"export LD_PRELOAD=libcef.so\" | sudo -u %s tee -a ~/.bashrc",systemUser));
                            //bf.newLine();
                            bf.close();
                        }
                        if(Files.exists(outFile)){
                            jTextAreaCopying.append("firstinstall.sh created successfully in user folder");
                            jTextAreaCopying.append(System.lineSeparator());
                        } else {
                            System.out.println("Houston we have a problem. firstinstall.sh was not created in the user folder.");
                        }
                        //we have to make sure we don't overwrite a good launch file with the wrong values, let's check if it doesn't already exist
                        Path outFile2 = Paths.get(System.getProperty("user.home"),".BibleGetOpenOfficePlugin","launch.sh");
                        if( Files.exists(outFile2) ){
                            jTextAreaCopying.append("launch.sh seems to exist already? not writing");
                            jTextAreaCopying.append(System.lineSeparator());
                            System.out.println("this is so strange, why does it exist?");
                        } else {
                            try (FileWriter writer = new FileWriter(outFile2.toFile()); BufferedWriter bf = new BufferedWriter(writer)) {
                                bf.write("#!/bin/bash");
                                bf.newLine();
                                bf.write("LD_LIBRARY_PATH=~/.BibleGetOpenOfficePlugin/JCEF LD_PRELOAD=~/.BibleGetOpenOfficePlugin/JCEF/libcef.so " + BibleGetIO.sofficeLaunchSymlink + " &" );
                                bf.newLine();
                                bf.close();
                                if(Files.exists(outFile2)){
                                    jTextAreaCopying.append("launch.sh created successfully in user folder");
                                    jTextAreaCopying.append(System.lineSeparator());
                                } else {
                                    System.out.println("Houston we have a problem. launch.sh was not created in the user folder.");
                                }
                            }
                        }
                    
                        builder.directory(Paths.get(BibleGetIO.nativelibrarypath).toFile());
                        builder.command("/bin/bash","-c","chmod +x jcef_helper; chmod +x chrome-sandbox; chmod +x ../firstinstall.sh; chmod +x ../launch.sh");
                        process = builder.start();
                        streamGobbler = new BibleGetIO.StreamGobbler(process.getInputStream(), System.out::println);
                        Executors.newSingleThreadExecutor().submit(streamGobbler);
                        int exitCode = process.waitFor();
                        if(exitCode == 0){
                            jTextAreaCopying.append("Making jcef_helper, chrome-sandbox, and launch.sh files executable: SUCCESS!");
                        } else {
                            jTextAreaCopying.append("Making jcef_helper, chrome-sandbox, and launch.sh files executable: ERROR");
                        }
                        //the real test is whether the files actually exist and are executable
                        if(Files.exists(Paths.get(BibleGetIO.nativelibrarypath,"jcef_helper")) && Files.exists(Paths.get(BibleGetIO.nativelibrarypath,"chrome-sandbox")) && Files.exists(Paths.get(System.getProperty("user.home"),".BibleGetOpenOfficePlugin","launch.sh")) ){
                            if(Files.isExecutable(Paths.get(BibleGetIO.nativelibrarypath,"jcef_helper")) && Files.isExecutable(Paths.get(BibleGetIO.nativelibrarypath,"chrome-sandbox")) && Files.isExecutable(Paths.get(System.getProperty("user.home"),".BibleGetOpenOfficePlugin","launch.sh")) ){
                                jTextAreaCopying.append(System.lineSeparator());
                                jTextAreaCopying.append("jcef_helper, chrome-sandbox, and launch.sh files are confirmed executable");
                                BibleGetIO.ADDONSTATE = BGET.ADDONSTATE.JCEFCOPIED;
                                jLabelCopying.setIcon(checkmarkIco);                                
                            } else {
                                jLabelCopying.setIcon(xmarkIco);
                            }
                        } else {
                            jLabelCopying.setIcon(xmarkIco);
                        }
                        
                    }
                    
                    break;
                case "INSTALLDEPENDENCIES":
                    publish(25);
                    if(BibleGetIO.sysPkgsNeeded.size() > 0){
                        builder.command("/bin/bash","-c","echo " + new String(passwd) + "| sudo -S apt-get update && sudo -S apt-get install -y " + String.join(" ", BibleGetIO.sysPkgsNeeded) );
                        process = builder.start();
                        streamGobbler = new BibleGetIO.StreamGobbler(process.getInputStream(), jTextAreaInstalling::append, true);
                        Executors.newSingleThreadExecutor().submit(streamGobbler);
                        int exitCode1 = process.waitFor();
                        if(exitCode1 == 0){
                            publish(75);
                            jTextAreaInstalling.append("Packages installed: SUCCESS!");
                            publish(100);
                            jLabelInstalling.setIcon(checkmarkIco);
                            BibleGetIO.ADDONSTATE = BGET.ADDONSTATE.JCEFDEPENDENCIES;
                        } else {
                            jTextAreaInstalling.append("Packages installed: ERROR");
                            jLabelInstalling.setIcon(xmarkIco);
                        }
                    } else {
                        jTextAreaInstalling.append("Packages seem to have already been installed, skipping...");
                        publish(100);
                        jLabelInstalling.setIcon(checkmarkIco);
                        BibleGetIO.ADDONSTATE = BGET.ADDONSTATE.JCEFDEPENDENCIES;                        
                    }
                    break;
                case "PREPAREENV":
                    publish(50);
                    String command = "echo " + new String(passwd) + "| sudo -S ln -sfn " + System.getProperty("user.home") + "/.BibleGetOpenOfficePlugin/launch.sh " + BibleGetIO.sofficeLaunch;
                    System.out.println("attempting to run command:");
                    System.out.println(command);
                    builder.command("/bin/bash","-c", command);
                    process = builder.start();
                    streamGobbler = new BibleGetIO.StreamGobbler(process.getInputStream(), jTextAreaInstalling::append, true);
                    Executors.newSingleThreadExecutor().submit(streamGobbler);
                    int exitCode2 = process.waitFor();
                    if(exitCode2 == 0){
                        publish(100);
                        jTextAreaPreparing.append("soffice symlink updated: SUCCESS!");
                        jTextAreaPreparing.append(System.lineSeparator());
                        jLabelPreparing.setIcon(checkmarkIco);
                        BibleGetIO.ADDONSTATE = BGET.ADDONSTATE.JCEFENVREADY;
                    } else {
                        jTextAreaPreparing.append("soffice symlink updated: ERROR");
                        jLabelPreparing.setIcon(xmarkIco);
                    }
                    passwd = null;
                    break;
            }
            return null;
        }
        
        @Override
        protected void done(){
            System.out.println("Background worker has finished task " + this.currentTask);
            Task_Force tf;
            switch(this.currentTask){
                case "DOWNLOADJCEF":
                    if(BibleGetIO.ADDONSTATE == BGET.ADDONSTATE.JCEFDOWNLOADED){
                        System.out.println("Seeing that ADDONSTATE changed successfully to JCEFDOWNLOADED, we can continue with the COPYJCEF task");
                        tf = new Task_Force(jProgressBars,"COPYJCEF");
                        tf.execute();
                    } else {
                        System.out.println("ADDON is not in a state to continue with the next task. We expected to find JCEFDOWNLOADED state, instead we have " + BibleGetIO.ADDONSTATE.name());
                    }
                    break;
                case "COPYJCEF":
                    if(BibleGetIO.ADDONSTATE == BGET.ADDONSTATE.JCEFCOPIED){
                        System.out.println("Seeing that ADDONSTATE changed successfully to JCEFCOPIED, we can continue with the INSTALLDEPENDENCIES task");
                        jTextAreaInstalling.append("Some system dependencies need to be installed. This requires your system password.\n");
                        jTextAreaInstalling.append("You can type your password here for an automatic installation,\n");
                        jTextAreaInstalling.append("or if you prefer you can manually run the script at " + System.getProperty("user.home") + "/.BibleGetOpenOfficePlugin/firstinstall.sh\n");
                        jLabel7.setText("Please type system password to install system dependencies.");
                    } else {
                        System.out.println("ADDON is not in a state to continue with the next task. We expected to find JCEFCOPIED state, instead we have " + BibleGetIO.ADDONSTATE.name());
                    }
                    break;
                case "INSTALLDEPENDENCIES":
                    if(BibleGetIO.ADDONSTATE == BGET.ADDONSTATE.JCEFDEPENDENCIES){
                        System.out.println("Seeing that ADDONSTATE changed successfully to JCEFDEPENDENCIES, we can continue with the PREPAREENV task");
                        tf = new Task_Force(jProgressBars,"PREPAREENV");
                        tf.execute();
                    } else {
                        System.out.println("ADDON is not in a state to continue with the next task. We expected to find JCEFDEPENDENCIES state, instead we have " + BibleGetIO.ADDONSTATE.name());
                    }
                    break;
                case "PREPAREENV":
                    if(BibleGetIO.ADDONSTATE == BGET.ADDONSTATE.JCEFENVREADY){
                        //what should we do to celebrate?
                        jTextAreaPreparing.append("Installation is complete.\nPlease restart OpenOffice to enjoy full functionality.");
                    }
                    break;
            }
        }
    }

    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabelCopying;
    private javax.swing.JLabel jLabelDownloading;
    private javax.swing.JLabel jLabelInstalling;
    private javax.swing.JLabel jLabelPreparing;
    private javax.swing.JLabel jLabelTotalProgress;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanelBottom;
    private javax.swing.JPanel jPanelCopying;
    private javax.swing.JPanel jPanelDownloading;
    private javax.swing.JPanel jPanelInstalling;
    private javax.swing.JPanel jPanelIntro;
    private javax.swing.JPanel jPanelPreparing;
    private javax.swing.JPasswordField jPasswordField1;
    private javax.swing.JProgressBar jProgressBarCopying;
    private javax.swing.JProgressBar jProgressBarDownloading;
    private javax.swing.JProgressBar jProgressBarInstalling;
    private javax.swing.JProgressBar jProgressBarPreparing;
    private javax.swing.JProgressBar jProgressBarTotal;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextAreaCopying;
    private javax.swing.JTextArea jTextAreaDownloading;
    private javax.swing.JTextArea jTextAreaInstalling;
    private javax.swing.JTextArea jTextAreaPreparing;
    // End of variables declaration//GEN-END:variables
}
