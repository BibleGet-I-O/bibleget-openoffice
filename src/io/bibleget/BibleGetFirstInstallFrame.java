/*
 * Copyright 2020 johnrdorazio.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.bibleget;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import javax.net.ssl.HttpsURLConnection;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JProgressBar;
import javax.swing.SwingWorker;
import javax.swing.text.DefaultCaret;
import org.apache.commons.lang3.SystemUtils;

/**
 *
 * @author johnrdorazio
 */
public class BibleGetFirstInstallFrame extends javax.swing.JFrame {

    private final ImageIcon loadingIco = new ImageIcon(getClass().getResource("/io/bibleget/images/loading.gif"));
    private final ImageIcon checkmarkIco = new ImageIcon(getClass().getResource("/io/bibleget/images/green-checkmark.png"));
    private final ImageIcon xmarkIco = new ImageIcon(getClass().getResource("/io/bibleget/images/red-x-wrong-mark.png"));
    private static String nativelibrarypath = "";
    private static String ziplibrarypath = "";
    
    /**
     * Creates new form BibleGetFirstInstallFrame
     */
    public BibleGetFirstInstallFrame() throws IOException {
        
        initComponents();
        
        ArrayList<JProgressBar> jProgressBars = new ArrayList<>();
        jProgressBars.add(jProgressBar1);
        jProgressBars.add(jProgressBar2);
        jProgressBars.add(jProgressBar3);
        jProgressBars.add(jProgressBar4);
        Task_Force tf = null;
        switch(BibleGetIO.ADDONSTATE){
            case JCEFUNINITIALIZED:
                tf = new Task_Force(jProgressBars,"DOWNLOADJCEF");
                break;
            case JCEFDOWNLOADED:
                tf = new Task_Force(jProgressBars,"COPYJCEF");
                break;
            case JCEFCOPIED:
                break;
            case JCEFDEPENDENCIES:
                break;
            case JCEFENVREADY:
                break;
        }
        if(null != tf){
            tf.execute();
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jProgressBar1 = new javax.swing.JProgressBar();
        jTextArea1 = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        jLabel1.setHorizontalTextPosition(JLabel.LEFT);
        jLabel2 = new javax.swing.JLabel();
        jLabel2.setHorizontalTextPosition(JLabel.LEFT);
        jLabel3 = new javax.swing.JLabel();
        jLabel3.setHorizontalTextPosition(JLabel.LEFT);
        jProgressBar2 = new javax.swing.JProgressBar();
        jProgressBar3 = new javax.swing.JProgressBar();
        jProgressBar4 = new javax.swing.JProgressBar();
        jSeparator1 = new javax.swing.JSeparator();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextAreaDownloading = new javax.swing.JTextArea();
        DefaultCaret caret = (DefaultCaret)jTextAreaDownloading.getCaret();
        caret.setUpdatePolicy(DefaultCaret.ALWAYS_UPDATE);
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextAreaCopying = new javax.swing.JTextArea();
        jLabel5 = new javax.swing.JLabel();
        jProgressBar5 = new javax.swing.JProgressBar();
        jLabel6 = new javax.swing.JLabel();
        jTextFieldPasswd = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jLabel7 = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextAreaInstalling = new javax.swing.JTextArea();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("BibleGet installation");
        setAlwaysOnTop(true);
        setMinimumSize(new java.awt.Dimension(700, 500));
        setPreferredSize(new java.awt.Dimension(700, 500));

        jProgressBar1.setStringPainted(true);

        jTextArea1.setEditable(false);
        jTextArea1.setColumns(20);
        jTextArea1.setLineWrap(true);
        jTextArea1.setRows(2);
        jTextArea1.setText("In order to function correctly, the BibleGet add-on for OpenOffice requires some additional components.\nPlease wait patiently while the setup process completes.");
        jTextArea1.setWrapStyleWord(true);
        jTextArea1.setOpaque(false);

        jLabel1.setFont(new java.awt.Font("Dialog", 1, 18)); // NOI18N
        jLabel1.setIcon(loadingIco);
        jLabel1.setText("1. Downloading JCEF component...");
        jLabel1.setPreferredSize(new java.awt.Dimension(347, 24));

        jLabel2.setFont(new java.awt.Font("Dialog", 1, 18)); // NOI18N
        jLabel2.setIcon(loadingIco);
        jLabel2.setText("3. Installing system dependencies...");
        jLabel2.setPreferredSize(new java.awt.Dimension(290, 24));

        jLabel3.setFont(new java.awt.Font("Dialog", 1, 18)); // NOI18N
        jLabel3.setIcon(loadingIco);
        jLabel3.setText("4. Preparing environment...");
        jLabel3.setPreferredSize(new java.awt.Dimension(289, 24));

        jProgressBar2.setStringPainted(true);

        jProgressBar3.setStringPainted(true);

        jProgressBar4.setStringPainted(true);

        jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel4.setText("Total progress");

        jTextAreaDownloading.setEditable(false);
        jTextAreaDownloading.setColumns(20);
        jTextAreaDownloading.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        jTextAreaDownloading.setForeground(new java.awt.Color(0, 102, 0));
        jTextAreaDownloading.setRows(5);
        jTextAreaDownloading.setText("Establishing connection to the github repo for the JCEF component https://github.com/jcefbuild/jcefbuild...\n");
        jTextAreaDownloading.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jScrollPane1.setViewportView(jTextAreaDownloading);

        jTextAreaCopying.setEditable(false);
        jTextAreaCopying.setColumns(20);
        jTextAreaCopying.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        jTextAreaCopying.setForeground(new java.awt.Color(0, 102, 0));
        jTextAreaCopying.setRows(5);
        jScrollPane2.setViewportView(jTextAreaCopying);

        jLabel5.setFont(new java.awt.Font("Dialog", 1, 18)); // NOI18N
        jLabel5.setText("2. Copying JCEF component files...");

        jProgressBar5.setStringPainted(true);

        jLabel6.setLabelFor(jTextFieldPasswd);
        jLabel6.setText("System password:");

        jTextFieldPasswd.setFont(new java.awt.Font("Dialog", 0, 14)); // NOI18N
        jTextFieldPasswd.setText("jTextField1");

        jButton1.setText("OK");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel7.setForeground(new java.awt.Color(153, 0, 0));

        jTextAreaInstalling.setEditable(false);
        jTextAreaInstalling.setColumns(20);
        jTextAreaInstalling.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        jTextAreaInstalling.setForeground(new java.awt.Color(0, 102, 0));
        jTextAreaInstalling.setRows(5);
        jScrollPane3.setViewportView(jTextAreaInstalling);

        jTextArea2.setEditable(false);
        jTextArea2.setColumns(20);
        jTextArea2.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        jTextArea2.setForeground(new java.awt.Color(0, 102, 0));
        jTextArea2.setRows(5);
        jScrollPane4.setViewportView(jTextArea2);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 400, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 400, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 400, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 400, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGroup(layout.createSequentialGroup()
                                    .addGap(12, 12, 12)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 131, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jTextFieldPasswd, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jButton1)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, 247, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addComponent(jProgressBar2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 667, Short.MAX_VALUE)
                                        .addComponent(jProgressBar3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(jScrollPane4)))
                                .addComponent(jTextArea1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addContainerGap())
                        .addGroup(layout.createSequentialGroup()
                            .addGap(12, 12, 12)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 667, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(jProgressBar1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 667, Short.MAX_VALUE)))
                            .addContainerGap()))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(12, 12, 12)
                                .addComponent(jProgressBar5, javax.swing.GroupLayout.PREFERRED_SIZE, 667, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addComponent(jProgressBar4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 679, Short.MAX_VALUE)
                                .addComponent(jLabel4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jSeparator1, javax.swing.GroupLayout.Alignment.LEADING)))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTextArea1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jProgressBar1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel5)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jProgressBar5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jProgressBar2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(12, 12, 12)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldPasswd, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel6)
                    .addComponent(jButton1)
                    .addComponent(jLabel7))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jProgressBar3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 71, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jProgressBar4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jButton1ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(BibleGetFirstInstallFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(BibleGetFirstInstallFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(BibleGetFirstInstallFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(BibleGetFirstInstallFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                try {
                    new BibleGetFirstInstallFrame().setVisible(true);
                } catch (IOException ex) {
                    Logger.getLogger(BibleGetFirstInstallFrame.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }
    
    private class Task_Force extends SwingWorker<Void, Integer> {
        JProgressBar jProgressBar1;
        JProgressBar jProgressBar2;
        JProgressBar jProgressBar3;
        JProgressBar jProgressBar4;
        
        String currentTask;
        
        public Task_Force(ArrayList<JProgressBar> jpbs,String task){
            this.jProgressBar1 = jpbs.get(0);
            this.jProgressBar2 = jpbs.get(1);
            this.jProgressBar3 = jpbs.get(2);
            this.jProgressBar4 = jpbs.get(3);
            this.currentTask = task;
        }

        @Override
        protected void process(List<Integer> chunks) {
            int i = chunks.get(chunks.size()-1);
            jProgressBar1.setValue(i); // The last value in this array is all we care about.
            jProgressBar4.setValue(Math.round(i/4));
            //System.out.println(i);            
        }
        
        @Override
        protected Void doInBackground() throws Exception {
            publish(0);
            System.out.println("BibleGetFirstInstall started background worker for task " + this.currentTask);
            switch(this.currentTask){
                case "DOWNLOADJCEF":
                    try {
                        System.out.println("starting downloadJCEF process...");
                        //following URLs retrieved via the github api at
                        //    https://api.github.com/repos/jcefbuild/jcefbuild/releases/30632029/assets
                        // actually the same information is present in:
                        //    https://api.github.com/repos/jcefbuild/jcefbuild/releases
                        // use Accept header = application/vnd.github.v3+json in order to retrieve results in JSON notation
                        // the result of this last API endpoint is an ARRAY of objects, the first of which should be the latest release
                        // but in order to target a specific release, search for "tag_name" (or "name", should be the same) 
                        //     as indicated in the following JCEFbuild String
                        //     The object that has this "tag_name" will also have an "assets" property at the same level as "tag_name"
                        //     "assets" is again an ARRAY of OBJECTS
                        //     We must search for objects that have "name" of: {"linux32.zip", "linux64.zip", "macosx64.zip", "win32.zip"}
                        //     and get their "url" and perhaps "content_type"

                        String JCEFbuild = "v1.0.10-84.3.8+gc8a556f+chromium-84.0.4147.105";
                        String[] targetOS = new String[]{"linux32.zip", "linux64.zip", "macosx64.zip", "win32.zip"};

                        //Until we automate the process, here are the hardcoded URLs for the target OSs, for the indicated release:
                        String linux32URL = "https://api.github.com/repos/jcefbuild/jcefbuild/releases/assets/24791124";
                        String linux64URL = "https://api.github.com/repos/jcefbuild/jcefbuild/releases/assets/24791106";
                        String macosx64URL = "https://api.github.com/repos/jcefbuild/jcefbuild/releases/assets/24791232";
                        String win32URL = "https://api.github.com/repos/jcefbuild/jcefbuild/releases/assets/24791067";

                        URL downloadURL = null;
                        if(SystemUtils.IS_OS_WINDOWS){
                            downloadURL = new URL(win32URL);
                        } else if (SystemUtils.IS_OS_MAC_OSX){
                            downloadURL = new URL(macosx64URL);
                        } else if (SystemUtils.IS_OS_LINUX){
                            switch(System.getProperty("sun.arch.data.model")){
                                case "64":
                                    downloadURL = new URL(linux64URL);
                                    break;
                                case "32":
                                    downloadURL = new URL(linux32URL);
                                    break;
                            }
                        }
                        System.out.println("download URL was detected as " + downloadURL.toString());

                        HttpsURLConnection con;
                        con = (HttpsURLConnection) downloadURL.openConnection();            
                         // optional default is GET
                        con.setRequestMethod("GET");
                        con.setRequestProperty("Accept", "application/octet-stream");


                        //System.out.println("Sending 'GET' request to URL : " + url);
                        //System.out.println("Response Code : " + con.getResponseCode());
                        int respCode;
                        respCode = con.getResponseCode();
                        Path outDir = null;
                        if(HttpsURLConnection.HTTP_OK == respCode) {
                            if(SystemUtils.IS_OS_LINUX || SystemUtils.IS_OS_WINDOWS ){
                                outDir = Paths.get(System.getProperty("java.io.tmpdir"),"BibleGetJCEF");
                                System.out.println("Temp directory where JCEF should or will be stored was detected as " + outDir.toString());
                                if(Files.notExists(outDir)){
                                    System.out.println("The BibleGetJCEF directory in the temp folder was not found, now creating...");
                                    File jcefDirectoryTMP = new File(outDir.toString());
                                    jcefDirectoryTMP.mkdir();
                                }
                            } else if( SystemUtils.IS_OS_MAC_OSX ){
                                outDir = Paths.get(System.getProperty("user.home"), "Library", "BibleGetOpenOfficePlugin" );
                            }

                            byte[] buffer = new byte[2048];
                            try ( 
                                    InputStream conInStr = con.getInputStream();
                                    BufferedInputStream buffInStr = new BufferedInputStream(conInStr);
                                    ZipInputStream zipInStream = new ZipInputStream(buffInStr);
                                ) {
                                System.out.println("We seem to have a stream of data from the github assets...");
                                //int contentLength = con.getContentLength();
                                //System.out.println("our connection is predicting content length " + contentLength);
                                //the above prediction (86442538) is exact, when comparing with the value declared by github
                                //however we are reading the bytes after they are decompressed, which changes this value
                                //and we can't predict with certainty the total size of the decompressed zip
                                //but after testing we know the length = 215399768
                                int readLength = 0;
                                int percentageCompleted = 0;
                                int totalEntries = 0;
                                Double totalBytes = Double.valueOf(215399768);
                                Double onehundred = Double.valueOf(100);
                                ZipEntry entry;
                                while ((entry = zipInStream.getNextEntry()) != null && outDir != null) {
                                    totalEntries++;
                                    if(entry.isDirectory()){
                                        File entryFile = new File(outDir.toString(), entry.getName());
                                        if(entryFile.exists() == false){
                                            System.out.println("directory " + entryFile.getCanonicalPath() + " did not exist, now creating...");
                                            entryFile.mkdirs();
                                        }
                                        jTextAreaDownloading.append("Creating folder " + entry.getName() + "  (" + totalEntries + " of 137)\n");
                                    } else {
                                        Path filePath = outDir.resolve(entry.getName());
                                        //instead of checking whether the file exists, we'll simply overwrite by passing false as second parameter to FileOutputStream
                                        //let's keep life simple, it doesn't take that long
                                        //File entryFile = new File(outDir.toString(), entry.getName());
                                        //if(entryFile.exists() == false){
                                            try (FileOutputStream fos = new FileOutputStream(filePath.toFile(), false);
                                                    BufferedOutputStream bos = new BufferedOutputStream(fos, buffer.length)) {
                                                int len;
                                                while ((len = zipInStream.read(buffer)) > 0) {
                                                    bos.write(buffer, 0, len);
                                                    readLength += len;
                                                    Double progress = (Double.valueOf(readLength) / totalBytes);
                                                    percentageCompleted = (int) Math.round(progress * onehundred);
                                                    publish(percentageCompleted);
                                                    //System.out.println("readLength so far is " + len + " and percentage is " + percentageCompleted);
                                                }
                                            }
                                        //}
                                        jTextAreaDownloading.append("Unzipping " + entry.getName() + "  (" + totalEntries + " of 137)\n");
                                    }
                                    
                                    //Double progress = (Double.valueOf(totalEntries) / Double.valueOf(137));
                                    //percentageCompleted = (int) Math.round(progress * Double.valueOf(100));
                                    //publish(percentageCompleted);
                                    //System.out.println("entries so far is " + totalEntries + " and percentage is " + percentageCompleted);
                                }
                                System.out.println("total entries = " + totalEntries);
                                jTextAreaDownloading.append("Download of JCEF component and unzipping complete!");
                                BibleGetIO.ADDONSTATE = BGET.ADDONSTATE.JCEFDOWNLOADED;
                            }
                        }
                        con.disconnect();
                        jLabel1.setIcon(checkmarkIco);
                    } catch (IOException ex) {
                        jLabel1.setIcon(xmarkIco);
                        Logger.getLogger(BibleGetFirstInstallFrame.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    break;
                case "COPYJCEF":
                    
                    String[] JCEFfiles = null;
                    String[] JCEFswiftshaderFiles = null;
                    if(SystemUtils.IS_OS_WINDOWS){
                        nativelibrarypath = "/AppData/Roaming/BibleGetOpenOfficePlugin/JCEF";
                        ziplibrarypath = "win32";
                        JCEFfiles = new String[]{
                            "cef.pak",
                            "cef_100_percent.pak",
                            "cef_200_percent.pak",
                            "cef_extensions.pak",
                            "chrome_elf.dll",
                            "d3dcompiler_47.dll",
                            "devtools_resources.pak",
                            "icudtl.dat",
                            "jcef.dll",
                            "jcef_helper.exe",
                            "libEGL.dll",
                            "libGLESv2.dll",
                            "libcef.dll",
                            "snapshot_blob.bin",
                            "v8_context_snapshot.bin"
                        };
                        JCEFswiftshaderFiles = new String[]{
                            "libEGL.dll",
                            "libGLESv2.dll"
                        };
                    }
                    else if(SystemUtils.IS_OS_LINUX){
                        nativelibrarypath = "/.BibleGetOpenOfficePlugin/JCEF";
                        switch(System.getProperty("sun.arch.data.model")){
                            case "64":
                                ziplibrarypath = "linux64";
                                break;
                            case "32":
                                ziplibrarypath = "linux32";
                                break;
                        }
                        JCEFfiles = new String[]{
                            "cef.pak",
                            "cef_100_percent.pak",
                            "cef_200_percent.pak",
                            "cef_extensions.pak",
                            "chrome-sandbox",
                            "devtools_resources.pak",
                            "icudtl.dat",
                            "jcef_helper",
                            "libcef.so",
                            "libEGL.so",
                            "libGLESv2.so",
                            "libjcef.so",
                            "snapshot_blob.bin",
                            "v8_context_snapshot.bin"
                        };
                        JCEFswiftshaderFiles = new String[]{
                            "libEGL.so",
                            "libGLESv2.so"
                        };
                    }
                    else if(SystemUtils.IS_OS_MAC_OSX){
                        nativelibrarypath = "/Library/BibleGetOpenOfficePlugin/jcef_app.app";
                        ziplibrarypath = "java-cef-build-bin/bin/jcef_app.app"; //(??? double check how macOS is supposed to work)
                    }

                    nativelibrarypath = System.getProperty("user.home") + nativelibrarypath;


                    if(SystemUtils.IS_OS_LINUX || SystemUtils.IS_OS_WINDOWS){

                        //first let's check if the JCEF directory exists in the user's home under our BibleGetOpenOfficePlugin directory
                        //and if not, we create it
                        Path JCEFpath = Paths.get(nativelibrarypath);
                        if(Files.notExists(JCEFpath)){
                            File jcefDirectory = new File(nativelibrarypath);
                            jcefDirectory.mkdirs();
                        }

                        String tempDir = System.getProperty("java.io.tmpdir");
                        //check if the necessary files exist in the user.path BibleGetIOOpenOffice/JCEF folder
                        if(JCEFfiles != null){
                            for(String fileName : JCEFfiles ){
                                Path filePath = Paths.get(nativelibrarypath, fileName);
                                if(Files.notExists(filePath) ){
                                    Path tempFilePath = Paths.get(tempDir, "BibleGetJCEF", "java-cef-build-bin", "bin", "lib", ziplibrarypath, fileName);
                                    if(Files.notExists(tempFilePath)){
                                        //if the file doesn't even exist in the temp path then we need to download or re-download the package from github
                                        BibleGetIO.ADDONSTATE = BGET.ADDONSTATE.JCEFUNINITIALIZED;
                                    }
                                    //now we can copy the missing file from the tempDir
                                    //TODO: move this to BibleGetFirstInstallFrame.java
                                    if(BibleGetIO.ADDONSTATE == BGET.ADDONSTATE.JCEFDOWNLOADED){
                                        Files.copy(tempFilePath,filePath);
                                    }
                                }
                            }
                        } else {
                            Logger.getLogger(BibleGetIO.class.getName()).log(Level.SEVERE, null, "setNativeLibraryDir() : We were not able to determine the correct folder structure for this system in order to ensure the correct functioning of the Chrome Embedded Framework.");
                        }

                        //check if the 'locales' subfolder exists in the user.path BibleGetIOOpenOffice/JCEF folder
                        //and if not create it
                        Path JCEFlocalespath = Paths.get(nativelibrarypath, "locales");
                        if(Files.notExists(JCEFlocalespath) ){
                            File jcefLocalesDir = new File(nativelibrarypath, "locales");
                            jcefLocalesDir.mkdir();
                        }

                        //Define the files that should be in the 'locales' subfolder
                        String[] JCEFlocaleFiles = new String[]{
                            "am.pak",
                            "ar.pak",
                            "bg.pak",
                            "bn.pak",
                            "ca.pak",
                            "cs.pak",
                            "da.pak",
                            "de.pak",
                            "el.pak",
                            "en-GB.pak",
                            "en-US.pak",
                            "es-419.pak",
                            "es.pak",
                            "et.pak",
                            "fa.pak",
                            "fi.pak",
                            "fil.pak",
                            "fr.pak",
                            "gu.pak",
                            "he.pak",
                            "hi.pak",
                            "hr.pak",
                            "hu.pak",
                            "id.pak",
                            "it.pak",
                            "ja.pak",
                            "kn.pak",
                            "ko.pak",
                            "lt.pak",
                            "lv.pak",
                            "ml.pak",
                            "mr.pak",
                            "ms.pak",
                            "nb.pak",
                            "nl.pak",
                            "pl.pak",
                            "pt-BR.pak",
                            "pt-PT.pak",
                            "ro.pak",
                            "ru.pak",
                            "sk.pak",
                            "sl.pak",
                            "sr.pak",
                            "sv.pak",
                            "sw.pak",
                            "ta.pak",
                            "te.pak",
                            "th.pak",
                            "tr.pak",
                            "uk.pak",
                            "vi.pak",
                            "zh-CN.pak",
                            "zh-TW.pak"
                        };

                        //check if the necessary files exist in the 'locales' subfolder of the user.path BibleGetIOOpenOffice/JCEF folder
                        for(String fileName : JCEFlocaleFiles ){
                            Path filePath = Paths.get(nativelibrarypath, "locales", fileName);
                            if(Files.notExists(filePath) ){
                                Path tempFilePath = Paths.get(tempDir, "BibleGetJCEF", "java-cef-build-bin", "bin", "lib", ziplibrarypath, "locales", fileName);
                                if(Files.notExists(tempFilePath)){
                                    //if the file doesn't even exist in the temp path then we need to download or re-download the package from github
                                    BibleGetIO.ADDONSTATE = BGET.ADDONSTATE.JCEFUNINITIALIZED;
                                }
                                //now we can copy the missing file from the tempDir
                                //TODO: move this to BibleGetFirstInstallFrame.java
                                if(BibleGetIO.ADDONSTATE == BGET.ADDONSTATE.JCEFDOWNLOADED){
                                    Files.copy(tempFilePath,filePath);
                                }
                            }
                        }

                        //check if the 'swiftshader' subfolder exists in the user.path BibleGetIOOpenOffice/JCEF folder
                        //and if not create it
                        Path JCEFswshaderpath = Paths.get(nativelibrarypath, "swiftshader");
                        if(Files.notExists(JCEFswshaderpath) ){
                            File jcefSwShaderDir = new File(nativelibrarypath, "swiftshader");
                            jcefSwShaderDir.mkdir();
                        }

                        //check if the necessary files exist in the 'swiftshader subfolder
                        if(JCEFswiftshaderFiles != null){
                            for(String fileName : JCEFswiftshaderFiles ){
                                Path filePath = Paths.get(nativelibrarypath, "swiftshader", fileName);
                                if(Files.notExists(filePath) ){
                                    Path tempFilePath = Paths.get(tempDir, "BibleGetJCEF", "java-cef-build-bin", "bin", "lib", ziplibrarypath, "swiftshader", fileName);
                                    if(Files.notExists(tempFilePath)){
                                        //if the file doesn't even exist in the temp path then we need to download or re-download the package from github
                                        BibleGetIO.ADDONSTATE = BGET.ADDONSTATE.JCEFUNINITIALIZED;
                                    }
                                    //now we can copy the missing file from the tempDir
                                    //TODO: move this to BibleGetFirstInstallFrame.java
                                    if(BibleGetIO.ADDONSTATE == BGET.ADDONSTATE.JCEFDOWNLOADED){
                                        Files.copy(tempFilePath,filePath);
                                    }
                                }
                            }
                        } else {
                            Logger.getLogger(BibleGetIO.class.getName()).log(Level.SEVERE, null, "setNativeLibraryDir() : We were not able to determine the correct folder structure for this system in order to ensure the correct functioning of the Chrome Embedded Framework.");
                        }
                    } else if(SystemUtils.IS_OS_MAC_OSX){
                        //basically we don't nee the TEMP storage, because the app structure is exactly the same between the zip file and the user folder

                        //first let's check if the JCEF directory exists in the user's home under our BibleGetOpenOfficePlugin directory
                        //and if not, we create it
                        Path JCEFpath = Paths.get(nativelibrarypath);
                        if(Files.notExists(JCEFpath)){
                            //File jcefDirectory = new File(nativelibrarypath);
                            //jcefDirectory.mkdirs();
                            //The directory will be created when reading the zip file!
                            BibleGetIO.ADDONSTATE = BGET.ADDONSTATE.JCEFUNINITIALIZED;
                        }

                    }

        
                    
                    
                    Path tempFilePath = Paths.get(System.getProperty("java.io.tmpdir"), "BibleGetJCEF", "java-cef-build-bin", "bin", "lib", BibleGetIO.ziplibrarypath);
                    ProcessBuilder builder = new ProcessBuilder();
                    builder.directory(tempFilePath.toFile());
                    builder.command("/bin/bash","-c","chmod +x jcef_helper; chmod +x chrome-sandbox;");
                    Process process;
                    process = builder.start();
                    BibleGetIO.StreamGobbler streamGobbler = new BibleGetIO.StreamGobbler(process.getInputStream(), System.out::println);
                    Executors.newSingleThreadExecutor().submit(streamGobbler);
                    int exitCode = process.waitFor();
                    System.out.println(exitCode == 0 ? "process was successful" : "process was not successful");
                    break;
            }
            return null;
        }
        
        @Override
        protected void done(){
            System.out.println("Background worker has finished");
        }
    }

    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JProgressBar jProgressBar1;
    private javax.swing.JProgressBar jProgressBar2;
    private javax.swing.JProgressBar jProgressBar3;
    private javax.swing.JProgressBar jProgressBar4;
    private javax.swing.JProgressBar jProgressBar5;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JTextArea jTextAreaCopying;
    private javax.swing.JTextArea jTextAreaDownloading;
    private javax.swing.JTextArea jTextAreaInstalling;
    private javax.swing.JTextField jTextFieldPasswd;
    // End of variables declaration//GEN-END:variables
}
